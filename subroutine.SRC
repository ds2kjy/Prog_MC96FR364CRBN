; .\subroutine.SRC generated from: subroutine.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE subroutine.c LARGE ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND TABS(2) SRC(.\subroutine.SRC)

$NOMOD51

NAME	SUBROUTINE

P0	DATA	080H
P1	DATA	088H
P2	DATA	090H
P3	DATA	0C0H
T0	DATA	0B3H
T1	DATA	0B6H
EA	BIT	0A8H.7
PWM3DRH	DATA	0CCH
RDC0	DATA	0BDH
CDR0	DATA	0B3H
RDC1	DATA	0BAH
CDR1	DATA	0B6H
WTHDR	DATA	0DCH
PWM3DRL	DATA	0CBH
IEN0	DATA	0A8H
IEN1	DATA	0A9H
IE	DATA	0A8H
KITSR	DATA	0F7H
IEN2	DATA	0AAH
IEN3	DATA	0ABH
WDTMR	DATA	08DH
PWM3PRH	DATA	0CEH
P0PC	DATA	0C1H
PWM3PRL	DATA	0CDH
P0IO	DATA	098H
T0CR	DATA	0B2H
P1IO	DATA	0A0H
T1CR	DATA	0B4H
T0DR	DATA	0B3H
BCCR	DATA	08BH
P2IO	DATA	0B0H
T2CR	DATA	0C6H
T1DR	DATA	0B5H
P3IO	DATA	09BH
T3CR	DATA	0CAH
FECR	DATA	0ECH
RDBH	DATA	0C2H
UDATA0	DATA	0E7H
UDATA1	DATA	0FFH
UBAUD0	DATA	0E6H
UBAUD1	DATA	0FEH
CFHS	DATA	0BBH
RDBL	DATA	0C3H
I2CSAR	DATA	0A6H
EIENAB	DATA	0B1H
MCCR	DATA	0EFH
NCCR	DATA	089H
BODR	DATA	086H
CFLS	DATA	0BCH
EIFLAG	DATA	0ACH
FEMR	DATA	0E1H
SCCR	DATA	08AH
P00	BIT	080H.0
FESR	DATA	0EDH
RDRH	DATA	0C4H
PCON	DATA	087H
P10	BIT	088H.0
P01	BIT	080H.1
BITR	DATA	08CH
P20	BIT	090H.0
P11	BIT	088H.1
P02	BIT	080H.2
P30	BIT	0C0H.0
P21	BIT	090H.1
P12	BIT	088H.2
P03	BIT	080H.3
P31	BIT	0C0H.1
P22	BIT	090H.2
P13	BIT	088H.3
P04	BIT	080H.4
RDRL	DATA	0C5H
P32	BIT	0C0H.2
P23	BIT	090H.3
P14	BIT	088H.4
P05	BIT	080H.5
P33	BIT	0C0H.3
P24	BIT	090H.4
P15	BIT	088H.5
P06	BIT	080H.6
P34	BIT	0C0H.4
P25	BIT	090H.5
P16	BIT	088H.6
P07	BIT	080H.7
RODR	DATA	0BEH
P35	BIT	0C0H.5
P26	BIT	090H.6
P17	BIT	088H.7
P36	BIT	0C0H.6
P27	BIT	090H.7
WTCR0H	DATA	0F1H
P37	BIT	0C0H.7
WTCR1H	DATA	0F3H
EIPOLA	DATA	0AFH
WTCR2H	DATA	0F5H
MCRC_CTRL	DATA	0A1H
I2CSCLHR	DATA	09FH
PWM1DR	DATA	0B6H
WTCR0L	DATA	0F2H
IE1	DATA	0A9H
WTCR1L	DATA	0F4H
IE2	DATA	0AAH
WTCR2L	DATA	0F6H
I2CSCLLR	DATA	09EH
PWM1HR	DATA	0B7H
IE3	DATA	0ABH
WDTR	DATA	08EH
USTAT0	DATA	0E5H
USTAT1	DATA	0FDH
PWM1PR	DATA	0B5H
WTMR	DATA	0D1H
T2H	DATA	0C7H
T3H	DATA	0CCH
T3CR2	DATA	0C9H
WTSR	DATA	0D9H
MCRC_DATA0	DATA	099H
T2L	DATA	0CFH
IRCC0	DATA	0DDH
MCRC_DATA1	DATA	09AH
T3L	DATA	0CBH
IRCC1	DATA	0DEH
I2CCR	DATA	09CH
CDR2H	DATA	0C7H
IRCC2	DATA	0DFH
I2CDR	DATA	0A5H
CDR3H	DATA	0CCH
EIEDGE0	DATA	0ADH
IRCC3	DATA	0DAH
EIEDGE1	DATA	0AEH
IRCC4	DATA	0DBH
I2CSAR1	DATA	0A7H
CDR2L	DATA	0CFH
CDR3L	DATA	0CBH
ROB	DATA	0BFH
I2CSR	DATA	09DH
SRLC0	DATA	0D6H
T2HDR	DATA	0C7H
T2DRH	DATA	0C7H
SRLC1	DATA	0D7H
T3HDR	DATA	0CEH
T3DRH	DATA	0CEH
CFGCR	DATA	0F9H
FEARH	DATA	0E9H
T2LDR	DATA	0CFH
T2DRL	DATA	0CFH
T3LDR	DATA	0CDH
T3DRL	DATA	0CDH
FEARL	DATA	0EBH
FEARM	DATA	0EAH
UCTRL01	DATA	0E2H
UCTRL11	DATA	0FAH
UCTRL02	DATA	0E3H
UCTRL12	DATA	0FBH
UCTRL03	DATA	0E4H
UCTRL13	DATA	0FCH
I2CSDHR	DATA	0A3H
RMR	DATA	0E8H
WTDR0	DATA	0D5H
WTDR1	DATA	0D4H
FETCR	DATA	0EEH
SMRR0	DATA	0D2H
SMRR1	DATA	0D3H
BODSR	DATA	08FH
?PR?_HAL_FlashPageErase?SUBROUTINE       SEGMENT CODE INBLOCK 
?XD?_HAL_FlashPageErase?SUBROUTINE       SEGMENT XDATA OVERLAYABLE 
?PR?_HAL_FlashPageWrite?SUBROUTINE       SEGMENT CODE INBLOCK 
?XD?_HAL_FlashPageWrite?SUBROUTINE       SEGMENT XDATA OVERLAYABLE 
?PR?_HAL_FlashRead?SUBROUTINE            SEGMENT CODE INBLOCK 
?XD?_HAL_FlashRead?SUBROUTINE            SEGMENT XDATA OVERLAYABLE 
?PR?_MC96_WdtSet?SUBROUTINE              SEGMENT CODE INBLOCK 
?PR?_SYS_WdtSet?SUBROUTINE               SEGMENT CODE INBLOCK 
?PR?_?MC96_WdtRestart?SUBROUTINE         SEGMENT CODE INBLOCK 
?PR?INT_PCI0?SUBROUTINE                  SEGMENT CODE INBLOCK 
?C_INITSEG           SEGMENT CODE 
?XD?SUBROUTINE       SEGMENT XDATA 
	EXTRN	CODE (flash_program_mode_entry)
	EXTRN	CODE (?C?CLDOPTR)
	EXTRN	CODE (?C?LSTXDATA)
	EXTRN	CODE (?C?CSTOPTR)
	PUBLIC	gu16HalTimerT2
	PUBLIC	gu16HalTimerT1
	PUBLIC	gu8FlashPageBuffer
	PUBLIC	gu16HalTimer
	PUBLIC	gu16WdtResetTick
	PUBLIC	INT_PCI0
	PUBLIC	_?MC96_WdtRestart
	PUBLIC	_SYS_WdtSet
	PUBLIC	_MC96_WdtSet
	PUBLIC	?_HAL_FlashRead?BYTE
	PUBLIC	_HAL_FlashRead
	PUBLIC	?_HAL_FlashPageWrite?BYTE
	PUBLIC	_HAL_FlashPageWrite
	PUBLIC	_HAL_FlashPageErase

	XSEG  AT  08000H
gu8FlashPageBuffer:   DS   64

	RSEG  ?XD?_HAL_FlashPageErase?SUBROUTINE
?_HAL_FlashPageErase?BYTE:
u16FlashWordAddr?040:   DS   2

	RSEG  ?XD?_HAL_FlashRead?SUBROUTINE
?_HAL_FlashRead?BYTE:
u16CodeAddr?248:   DS   2
	ORG  2
 pu8ReadBuf?249:   DS   3
	ORG  5
 u16ByteLen?250:   DS   2
	ORG  7
         iw?251:   DS   2
	ORG  9
u32LastCodeAddr?252:   DS   4
	ORG  13
 pu8CodeBuf?253:   DS   2
	ORG  15
u16ReadSum_1?254:   DS   2
	ORG  17
u16ReadSum_2?255:   DS   2

	RSEG  ?XD?_HAL_FlashPageWrite?SUBROUTINE
?_HAL_FlashPageWrite?BYTE:
u16CodeAddr?142:   DS   2
	ORG  2
 pu8ByteBuf?143:   DS   3
	ORG  5
   u8Option?144:   DS   1
	ORG  6
   u8Status?146:   DS   1
	ORG  7
       u8EA?147:   DS   1

	RSEG  ?XD?SUBROUTINE
gu16WdtResetTick:   DS   2
   gu16HalTimer:   DS   2
 gu16HalTimerT1:   DS   2
 gu16HalTimerT2:   DS   2

	RSEG  ?C_INITSEG
	DB	042H
	DW	gu16HalTimer
	DW	00F00H

	DB	042H
	DW	gu16HalTimerT2
	DW	00F00H

	DB	042H
	DW	gu16HalTimerT1
	DW	00F00H

; //******************************************************************************
; // Title			: subroutine.c
; // Description		: timer, sub function, db etc
; // Programming date	: 2014. 10. 23
; //******************************************************************************
; 
; 
; #include	"global.h"
; 
; 
; 
; unsigned int xdata gu16HalTimer = 0x0f00;	// dummy
; unsigned int xdata gu16HalTimerT2 =0x0f00;	// dummy
; unsigned int xdata gu16HalTimerT1 =0x0f00;	// dummy
; 
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// 	Global variable for flash page buffer. Flash page buffer area : xdata[0x8000 ~ 0x807F(803f)
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; xdata unsigned char	gu8FlashPageBuffer[FLASH_BUFFER_SIZE] _at_ 0x8000;
; 
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// 	Erases flash by 1 page(128 Bytes).
; ///
; ///	@param	void
; ///	@return	void
; ///	@note	When this function is called directly, the flash is not erased. 
; ///			It is valid only when called in HAL_FlashPageWrite().
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; void HAL_FlashPageErase(unsigned int u16FlashWordAddr)

	RSEG  ?PR?_HAL_FlashPageErase?SUBROUTINE
_HAL_FlashPageErase:
	USING	0
			; SOURCE LINE # 33
	MOV  	DPTR,#u16FlashWordAddr?040
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 34
; 	unsigned char	ib;
; 
; 	/* Step 1. Enter the flash program mode */
; 	flash_program_mode_entry();
			; SOURCE LINE # 38
	LCALL	flash_program_mode_entry
; 
; 	/* Step 2. Reset page buffer */
; 	FECR = 0x00;
			; SOURCE LINE # 41
	CLR  	A
	MOV  	FECR,A
; 	_nop_(); _nop_(); _nop_();
			; SOURCE LINE # 42
	NOP  	
	NOP  	
	NOP  	
; 
; 	/* Step 3. Load page buffer. */
; 	for(ib = 0; ib < FLASH_BUFFER_SIZE; ib++)
			; SOURCE LINE # 45
;---- Variable 'ib?041' assigned to Register 'R7' ----
?C0001:
; 	{
			; SOURCE LINE # 46
; 		gu8FlashPageBuffer[ib] = 0x00;
			; SOURCE LINE # 47
	MOV  	R7,#040H
	MOV  	DPTR,#gu8FlashPageBuffer
	CLR  	A
?C0034:
	MOVX 	@DPTR,A
	INC  	DPTR
	DJNZ 	R7,?C0034
; 	}
			; SOURCE LINE # 48
?C0002:
; 
; 	/* Step 4. Set page address. */
; 	FEARH = 0;		// Bank
			; SOURCE LINE # 51
	CLR  	A
	MOV  	FEARH,A
; 	FEARM = (unsigned char)(u16FlashWordAddr>>8);
			; SOURCE LINE # 52
	MOV  	DPTR,#u16FlashWordAddr?040
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	A,R4
	MOV  	FEARM,A
; 	FEARL = (unsigned char)u16FlashWordAddr & 0xFF;
			; SOURCE LINE # 53
	MOV  	A,R5
	MOV  	FEARL,A
; 
; 	/* Step 5. Set erase time. */
; 	FETCR = 0xEA;      // 2.5ms @12MHz;
			; SOURCE LINE # 56
	MOV  	FETCR,#0EAH
; 
; 	/* Step 6. Start page erase */
; 	FECR = 0x03;		//erase_start(); 364b
			; SOURCE LINE # 59
	MOV  	FECR,#03H
; //	FECR = 0x0B;		//erase_start(); 116c
; 	_nop_(); _nop_(); _nop_(); _nop_(); _nop_();	// 5 nop instructions recommended after cpu stop during for erase or write operation.
			; SOURCE LINE # 61
	NOP  	
	NOP  	
	NOP  	
	NOP  	
	NOP  	
?C0004:
; 
; 	/* Step 7. Wait process done */
; 	while((FESR & BIT7) == 0x00);
			; SOURCE LINE # 64
	MOV  	A,FESR
	JNB  	ACC.7,?C0004
?C0005:
; 
; 	/* Step 8. Exit from program mode */
; 	//FECR |= 0x30;
; }
			; SOURCE LINE # 68
?C0006:
	RET  	
; END OF _HAL_FlashPageErase

; 
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// 	Writes flash by 1 page(128 Bytes).
; ///
; ///	@param	u16CodeAddr	: Code address from which flash is written
; ///	@param	pu8ByteBuf	: Pointer to the buffer to be written.
; ///	@param	u8Option		: Option for writing
; ///				\n	bit[7:1]	: reserved
; ///				\n	bit[0]	: 1=Erasing only. Writing is not permitted.
; ///	@return	unsigned char. Status.
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; unsigned char HAL_FlashPageWrite(unsigned int u16CodeAddr, unsigned char* pu8ByteBuf, unsigned char u8Option)

	RSEG  ?PR?_HAL_FlashPageWrite?SUBROUTINE
_HAL_FlashPageWrite:
	USING	0
			; SOURCE LINE # 82
	MOV  	DPTR,#pu8ByteBuf?143
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#u16CodeAddr?142
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 83
; 	unsigned char	ib;
; 	unsigned char	u8Status;
; 
; //	unsigned char	code * pu8CodeBuf;
; //	unsigned char	u8WriteLoop;
; //	unsigned int	u16WriteSum;
; //	unsigned int	u16ReadSum;
; 	unsigned char	u8EA;
; 
; 	if(u16CodeAddr & (FLASH_BUFFER_SIZE-1))					// 64 OR 128 bytes align
			; SOURCE LINE # 93
	ANL  	A,#03FH
	JZ   	?C0007
; 	{
			; SOURCE LINE # 94
; 		assert_error(FLASH_CODE | RETURN_FLASH_ALIGN_FAILURE);
			; SOURCE LINE # 95
	NOP  	
; 		return RETURN_FLASH_ALIGN_FAILURE;
			; SOURCE LINE # 96
	MOV  	R7,#014H
	RET  	
; 	}
			; SOURCE LINE # 97
?C0007:
; 
; 	SYS_WdtSet(1000);
			; SOURCE LINE # 99
	MOV  	R7,#0E8H
	MOV  	R6,#03H
	LCALL	_SYS_WdtSet
; 	/* Step 1. Erase flash page */
; 	SYS_WdtSet(0);
			; SOURCE LINE # 101
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	LCALL	_SYS_WdtSet
; 	u8EA = EA;
			; SOURCE LINE # 102
	MOV  	C,EA
	CLR  	A
	RLC  	A
	MOV  	DPTR,#u8EA?147
	MOVX 	@DPTR,A
; 	EA = 0;
			; SOURCE LINE # 103
	CLR  	EA
; 	HAL_FlashPageErase(u16CodeAddr);
			; SOURCE LINE # 104
	MOV  	DPTR,#u16CodeAddr?142
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_HAL_FlashPageErase
; 
; 	if(u8Option & BIT0)
			; SOURCE LINE # 106
	MOV  	DPTR,#u8Option?144
	MOVX 	A,@DPTR
	JNB  	ACC.0,?C0009
; 	{
			; SOURCE LINE # 107
; 		u8Status = RETURN_FLASH_SUCCESS;
			; SOURCE LINE # 108
	CLR  	A
	INC  	DPTR
	MOVX 	@DPTR,A
; 		goto JP_HAL_FlashPageWrite;
			; SOURCE LINE # 109
	SJMP 	?_HAL_FlashPageWrite?JP_HAL_FlashPageWrite
; 	}
			; SOURCE LINE # 110
?C0009:
; 
; 	/* Step 2. Enter the flash program mode */
; 	flash_program_mode_entry();
			; SOURCE LINE # 113
	LCALL	flash_program_mode_entry
; 
; 	/* Step 3. Page write. */
; //	for(u8WriteLoop=0 ; u8WriteLoop<100 ; u8WriteLoop++)
; 	{
			; SOURCE LINE # 117
; 
; 
; 		/* Step 3-1. Reset page buffer */
; 		FECR = 0x00;
			; SOURCE LINE # 121
	CLR  	A
	MOV  	FECR,A
; 		_nop_();
			; SOURCE LINE # 122
	NOP  	
; 
; 		/* Step 3-2. Load page buffer. */
; //		u16WriteSum = 0;
; 		for(ib = 0; ib < FLASH_BUFFER_SIZE; ib++)
			; SOURCE LINE # 126
;---- Variable 'ib?145' assigned to Register 'R7' ----
	MOV  	R7,A
?C0011:
; 		{
			; SOURCE LINE # 127
; //			u16WriteSum += gu8FlashPageBuffer[ib] = pu8ByteBuf[ib];
; 			gu8FlashPageBuffer[ib] = pu8ByteBuf[ib];
			; SOURCE LINE # 129
	MOV  	DPTR,#pu8ByteBuf?143
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPL,R7
	MOV  	DPH,#00H
	LCALL	?C?CLDOPTR
	MOV  	R6,A
	MOV  	A,#LOW (gu8FlashPageBuffer)
	ADD  	A,R7
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,#HIGH (gu8FlashPageBuffer)
	MOV  	DPH,A
	MOV  	A,R6
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 130
	INC  	R7
	MOV  	A,R7
	CJNE 	A,#040H,?C0011
?C0012:
; 		_nop_(); _nop_(); _nop_();
			; SOURCE LINE # 131
	NOP  	
	NOP  	
	NOP  	
; 
; 		/* Step 3-3. Set page address. */
; 		FEARH = 0;		// Bank
			; SOURCE LINE # 134
	CLR  	A
	MOV  	FEARH,A
; 		FEARM = (unsigned char)(u16CodeAddr >> 8);
			; SOURCE LINE # 135
	MOV  	DPTR,#u16CodeAddr?142
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	A,R4
	MOV  	FEARM,A
; 		FEARL = (unsigned char)(u16CodeAddr & 0xFF);
			; SOURCE LINE # 136
	MOV  	A,R5
	MOV  	FEARL,A
; 
; 		/* Step 3-4. Set write time. */
; 		FETCR = 0xEA;      // 2.5ms @12MHz;
			; SOURCE LINE # 139
	MOV  	FETCR,#0EAH
; 
; 		/* Step 3-5. Start page Write */
; 		FECR = 0x05;		//program_start();
			; SOURCE LINE # 142
	MOV  	FECR,#05H
; 		_nop_(); _nop_(); _nop_(); _nop_(); _nop_();	// 5 nop instructions recommended after cpu stop during for erase or write operation.
			; SOURCE LINE # 143
	NOP  	
	NOP  	
	NOP  	
	NOP  	
	NOP  	
?C0014:
; 
; 		/* Step 3-6. Wait process done */
; 		while((FESR & BIT7) == 0x00);
			; SOURCE LINE # 146
	MOV  	A,FESR
	JNB  	ACC.7,?C0014
?C0015:
; 		u8Status = RETURN_FLASH_SUCCESS;
			; SOURCE LINE # 147
	CLR  	A
	MOV  	DPTR,#u8Status?146
	MOVX 	@DPTR,A
; #if 0
; 		/* Step 3-7. Check written page */
; 		FEARL &= ~0x7F;
; 		pu8CodeBuf = u16CodeAddr;
; 		u16ReadSum = 0;
; 		for(ib=0; ib<FLASH_BUFFER_SIZE; ib++)
; 		{
; 			u16ReadSum += pu8CodeBuf[ib];
; 		}
; 
; 		if(u16WriteSum == u16ReadSum)
; 		{
; 			u8Status = RETURN_FLASH_SUCCESS;
; 			break;
; 		}
; 		else
; 		{
; 			u8Status = RETURN_FLASH_PAGE_WRITE_FAIL;
; 		}
; #endif
; 	}
			; SOURCE LINE # 168
; 	EA = u8EA;
			; SOURCE LINE # 169
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOV  	EA,C
; 	JP_HAL_FlashPageWrite :
			; SOURCE LINE # 170
?_HAL_FlashPageWrite?JP_HAL_FlashPageWrite:
; 
; 	/* Step 4. Exit from program mode */
; 	FECR = 0x30;
			; SOURCE LINE # 173
	MOV  	FECR,#030H
; 
; 	if(u8Status)
			; SOURCE LINE # 175
	MOV  	DPTR,#u8Status?146
	MOVX 	A,@DPTR
	MOV  	R7,A
	JZ   	?C0016
; 	{
			; SOURCE LINE # 176
; 		assert_error(FLASH_CODE | u8Status);
			; SOURCE LINE # 177
	NOP  	
; 	}
			; SOURCE LINE # 178
?C0016:
; 
; 	return u8Status;
			; SOURCE LINE # 180
; }
			; SOURCE LINE # 181
?C0008:
	RET  	
; END OF _HAL_FlashPageWrite

; //#ifndef _20_LITE
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// 	Reads flash.
; ///
; ///	@param	u16CodeAddr	: Code address from which flash is read.
; ///	@param	pu8ReadBuf	: Pointer to the buffer in which read flash is stored.
; ///	@param	u16ByteLen	: Number of bytes to read.
; ///	@return	unsigned char. Status.
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; unsigned char HAL_FlashRead(unsigned int u16CodeAddr, unsigned char* pu8ReadBuf, unsigned int u16ByteLen)

	RSEG  ?PR?_HAL_FlashRead?SUBROUTINE
_HAL_FlashRead:
	USING	0
			; SOURCE LINE # 193
	MOV  	DPTR,#u16CodeAddr?248
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 194
; 	unsigned int	iw;
; 	unsigned long	u32LastCodeAddr;
; 	unsigned char	code * pu8CodeBuf;
; 
; 	unsigned int	u16ReadSum_1 = 0;
			; SOURCE LINE # 199
	CLR  	A
	MOV  	DPTR,#u16ReadSum_1?254
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	unsigned int	u16ReadSum_2 = 0;
			; SOURCE LINE # 200
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 
; 	u32LastCodeAddr = u16CodeAddr;
			; SOURCE LINE # 202
	MOV  	DPTR,#u16CodeAddr?248
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	CLR  	A
	MOV  	R4,A
	MOV  	R5,A
	MOV  	DPTR,#u32LastCodeAddr?252
	LCALL	?C?LSTXDATA
; 	u32LastCodeAddr += (u16ByteLen - 1);
			; SOURCE LINE # 203
	MOV  	DPTR,#u32LastCodeAddr?252
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	MOV  	DPTR,#u16ByteLen?250+01H
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOV  	R7,A
	MOV  	DPTR,#u16ByteLen?250
	MOVX 	A,@DPTR
	ADDC 	A,#0FFH
	MOV  	R6,A
	CLR  	A
	MOV  	R4,A
	MOV  	R5,A
	MOV  	A,R3
	ADD  	A,R7
	MOV  	R7,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R6,A
	MOV  	A,R5
	ADDC 	A,R1
	MOV  	R5,A
	MOV  	A,R4
	ADDC 	A,R0
	MOV  	R4,A
	MOV  	DPTR,#u32LastCodeAddr?252
	LCALL	?C?LSTXDATA
; 
; 	if(u32LastCodeAddr & 0xFFFF0000)
			; SOURCE LINE # 205
	MOV  	DPTR,#u32LastCodeAddr?252
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	A,R4
	ORL  	A,R5
	JZ   	?C0017
; 	{
			; SOURCE LINE # 206
; 		assert_error(FLASH_CODE | RETURN_FLASH_INVALID_ADDRESS);
			; SOURCE LINE # 207
	NOP  	
; 		return RETURN_FLASH_INVALID_ADDRESS;
			; SOURCE LINE # 208
	MOV  	R7,#012H
	RET  	
; 	}
			; SOURCE LINE # 209
?C0017:
; 
; 	pu8CodeBuf = u16CodeAddr;
			; SOURCE LINE # 211
	MOV  	DPTR,#u16CodeAddr?248
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#pu8CodeBuf?253
	XCH  	A,R7
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	for(iw=0 ; iw<u16ByteLen; iw++)
			; SOURCE LINE # 212
	CLR  	A
	MOV  	DPTR,#iw?251
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
?C0019:
	MOV  	DPTR,#u16ByteLen?250
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	CLR  	C
	SUBB 	A,R7
	MOV  	A,R4
	SUBB 	A,R6
	JNC  	?C0020
; 	{
			; SOURCE LINE # 213
; 		u16ReadSum_1 += pu8ReadBuf[iw] = pu8CodeBuf[iw];
			; SOURCE LINE # 214
	MOV  	DPTR,#pu8CodeBuf?253
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,R5
	MOV  	DPL,A
	MOV  	A,R6
	ADDC 	A,R4
	MOV  	DPH,A
	CLR  	A
	MOVC 	A,@A+DPTR
	MOV  	R7,A
	MOV  	DPTR,#pu8ReadBuf?249
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#iw?251
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPL,A
	MOV  	DPH,R4
	MOV  	A,R7
	LCALL	?C?CSTOPTR
	MOV  	R7,A
	MOV  	DPTR,#u16ReadSum_1?254+01H
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#u16ReadSum_1?254
	MOVX 	A,@DPTR
	ADDC 	A,#00H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 215
	MOV  	DPTR,#iw?251+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0035
	MOV  	DPTR,#iw?251
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0035:
	SJMP 	?C0019
?C0020:
; 
; 	// Check-Sum
; 	for(iw=0 ; iw<u16ByteLen ; iw++)
			; SOURCE LINE # 218
	CLR  	A
	MOV  	DPTR,#iw?251
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
?C0022:
	MOV  	DPTR,#u16ByteLen?250
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	CLR  	C
	SUBB 	A,R7
	MOV  	A,R4
	SUBB 	A,R6
	JNC  	?C0023
; 	{
			; SOURCE LINE # 219
; 		u16ReadSum_2 += pu8ReadBuf[iw];
			; SOURCE LINE # 220
	MOV  	DPTR,#pu8ReadBuf?249
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPL,R5
	MOV  	DPH,R4
	LCALL	?C?CLDOPTR
	MOV  	R7,A
	MOV  	DPTR,#u16ReadSum_2?255+01H
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#u16ReadSum_2?255
	MOVX 	A,@DPTR
	ADDC 	A,#00H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 221
	MOV  	DPTR,#iw?251+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0036
	MOV  	DPTR,#iw?251
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0036:
	SJMP 	?C0022
?C0023:
; 	
; 	// Compare Check-Sum & Return result
; 	if(u16ReadSum_1 == u16ReadSum_2)
			; SOURCE LINE # 224
	MOV  	DPTR,#u16ReadSum_2?255
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#u16ReadSum_1?254
	MOVX 	A,@DPTR
	CJNE 	A,AR6,?C0025
	INC  	DPTR
	MOVX 	A,@DPTR
	CJNE 	A,AR7,?C0025
; 	{
			; SOURCE LINE # 225
; 		return RETURN_FLASH_SUCCESS;
			; SOURCE LINE # 226
	MOV  	R7,#00H
	RET  	
; 	}
			; SOURCE LINE # 227
?C0025:
; 	else
; 	{
			; SOURCE LINE # 229
; 		return RETURN_FLASH_PAGE_READ_FAIL;
			; SOURCE LINE # 230
	MOV  	R7,#016H
; 	}
			; SOURCE LINE # 231
; }
			; SOURCE LINE # 232
?C0018:
	RET  	
; END OF _HAL_FlashRead

; 
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// 	Global variable which indicates the number of TIMER0's ticks before watchdog reset.
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; unsigned int	gu16WdtResetTick;
; 
; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// Sets watchdog timer.
; ///
; ///	@param	u8Ena		: 0=Disable, 1=Enable.
; ///	@param	u8ResetDur	: 43.7ms * u8ResetDur(@ 12MHz)
; ///	@return	UINT8. Status.
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; void MC96_WdtSet(unsigned char u8Ena, unsigned char u8ResetDur)

	RSEG  ?PR?_MC96_WdtSet?SUBROUTINE
_MC96_WdtSet:
	USING	0
			; SOURCE LINE # 250
;---- Variable 'u8ResetDur?357' assigned to Register 'R5' ----
;---- Variable 'u8Ena?356' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 251
; 	unsigned char	u8EA;
; 
; 	u8EA = EA;
			; SOURCE LINE # 254
	MOV  	C,EA
	CLR  	A
	RLC  	A
	MOV  	R6,A
;---- Variable 'u8EA?358' assigned to Register 'R6' ----
; 	EA = 0;
			; SOURCE LINE # 255
	CLR  	EA
; 
; 	WDTMR &= ~BIT7;
			; SOURCE LINE # 257
	ANL  	WDTMR,#07FH
; 
; 	if(u8Ena)
			; SOURCE LINE # 259
	MOV  	A,R7
	JZ   	?C0027
; 	{
			; SOURCE LINE # 260
; 		WDTR = u8ResetDur;
			; SOURCE LINE # 261
	MOV  	R7,AR5
	MOV  	WDTR,R7
; 		WDTMR |= (BIT7|BIT5);
			; SOURCE LINE # 262
	ORL  	WDTMR,#0A0H
; 	}
			; SOURCE LINE # 263
?C0027:
; 
; 	EA = u8EA;
			; SOURCE LINE # 265
	MOV  	R7,AR6
	MOV  	A,R6
	ADD  	A,#0FFH
	MOV  	EA,C
; }
			; SOURCE LINE # 266
	RET  	
; END OF _MC96_WdtSet

; 
; void SYS_WdtSet(unsigned int u16Timer0Tick)

	RSEG  ?PR?_SYS_WdtSet?SUBROUTINE
_SYS_WdtSet:
	USING	0
			; SOURCE LINE # 268
;---- Variable 'u16Timer0Tick?459' assigned to Register 'R6/R7' ----
; {
			; SOURCE LINE # 269
; 	unsigned char	u8EA;
; 
; 	u8EA = EA;
			; SOURCE LINE # 272
	MOV  	C,EA
	CLR  	A
	RLC  	A
;---- Variable 'u8EA?460' assigned to Register 'R4' ----
	MOV  	R4,A
; 	EA = 0;
			; SOURCE LINE # 273
	CLR  	EA
; 
; 	if(u16Timer0Tick)	// WDT enable
			; SOURCE LINE # 275
	MOV  	A,R7
	ORL  	A,R6
	JZ   	?C0029
; 	{
			; SOURCE LINE # 276
; 		gu16WdtResetTick = u16Timer0Tick;
			; SOURCE LINE # 277
	MOV  	DPTR,#gu16WdtResetTick
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 		MC96_WdtSet(1, 30);		// 43.7ms * 30 = 1Sec(@ 12MHz)
			; SOURCE LINE # 278
	MOV  	R5,#01EH
	MOV  	R7,#01H
; 	} 
			; SOURCE LINE # 279
	SJMP 	?C0038
?C0029:
; 	else					// WDT disable
; 	{
			; SOURCE LINE # 281
; 		gu16WdtResetTick = 0;
			; SOURCE LINE # 282
	CLR  	A
	MOV  	DPTR,#gu16WdtResetTick
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 		MC96_WdtSet(0, 0);
			; SOURCE LINE # 283
	MOV  	R5,A
	MOV  	R7,A
?C0038:
	LCALL	_MC96_WdtSet
; 	}
			; SOURCE LINE # 284
?C0030:
; 
; 	EA = u8EA;
			; SOURCE LINE # 286
	MOV  	R7,AR4
	MOV  	A,R4
	ADD  	A,#0FFH
	MOV  	EA,C
; }
			; SOURCE LINE # 287
	RET  	
; END OF _SYS_WdtSet

; ///////////////////////////////////////////////////////////////////////////////////////////////
; ///	
; /// Restarts watchdog timer to prevent watchdog timeout.
; ///
; ///	@param	void
; ///	@return	void
; ///	
; ///////////////////////////////////////////////////////////////////////////////////////////////
; void MC96_WdtRestart(void) large reentrant

	RSEG  ?PR?_?MC96_WdtRestart?SUBROUTINE
_?MC96_WdtRestart:
			; SOURCE LINE # 296
; {
; 	WDTMR |= BIT5;
			; SOURCE LINE # 298
	ORL  	WDTMR,#020H
; }
			; SOURCE LINE # 299
	RET  	
; END OF _?MC96_WdtRestart

CSEG	AT	000ABH
	LJMP	INT_PCI0

; 
; 
; 
;  //======================================================
; // interrupt routines
; //======================================================
; 
; 
; void INT_PCI0() interrupt 21

	RSEG  ?PR?INT_PCI0?SUBROUTINE
	USING	0
INT_PCI0:
			; SOURCE LINE # 308
; {
; 	// Pin change interrupt (P0)
; 	// TODO: add your code here
; }
			; SOURCE LINE # 312
	RETI 	
; END OF INT_PCI0

	END
